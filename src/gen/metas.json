{
  "tags": [["nixos", 1], ["postgresql", 1], ["vue", 1], ["webdev", 1]],
  "pins": [2, 1],
  "posts": [
    {"id": 2, "title": "NixOS and PostgreSQL", "subtitle": "Migrating from PostgreSQL 14 to 15", "date": "27/11/2023", "tags": ["nixos", "postgresql"], "file": "posts/nixos-and-postgresql.md", "slug": "nixos-and-postgresql", "pinned": 0, "content": "When upgrading to version 15 from 14, there was an issue. None of my data was transferred. To fix this issue i swapped to the `posgres` user who is a superuser on the PostgreSQL databases.\n\nThen to preform the migration I ran:\n\n```sql\n-- to do this without swapping user you can use the flag -U\npg_dumpall > sqldump\n```\n\nthen when I had the sqldump file, the following command was run from the command line to get use the sqldump file to recover the previous data\n\n```bash\npsql -f sqldump\n```"},
    {"id": 1, "title": "Self-Healing URLs", "subtitle": "Creating self-healing URLs within my Vue.js website", "date": "10/12/2023", "tags": ["vue", "webdev"], "file": "posts/self-healing-urls.md", "slug": "self-healing-urls", "pinned": 0, "content": "I have been working on the creation of this [version](https://github.com/isabelroses/website/commit/8c53b9f3576d98a2ebe71976a3f921a30e6ad052) of my website for a while and when I finally thought I was done, I was introduced to the concept of self-healing URLs.\n\nSelf-healing URLs are designed in a way that if a user was to type in a URL as long as a certain part of the URL is correct, the user will be redirected to the correct page. This is useful for when a user is trying to access a page that has been moved or deleted.\n\nFor example, if a user was to type in [`https://isaberoses.com/blog/gaoengioa-2`](https://isaberoses.com/blog/gaoengioa-2) they would be redirected to [`https://isabelroses.com/blog/self-healing-urls-2`](https://isabelroses.com/blog/self-healing-urls-2) as the only important part of the URL is the \"2\" in this case, which refers to the second blog post by ID.\n\nTo implement this I had to make a few changes to my code. The original way that the post data was being fetched was by using the slug of the post. This meant that if the slug was incorrect, the post would not be found and the user would be redirected to a 404 page. To fix this I had to change the way that the post was being fetched to use the ID of the post instead. This meant that if the slug was incorrect, the post would still be found and the user would be redirected to the correct page.\n\n```js\n// the old code\nget post() {\n    return meta.posts.find((post: any) => post.slug == this.$route.params.slug);\n}\n\n// the new code\nget post() {\n        // get the id from the slug\n        const id = (this.$route.params.slug).toString().split(\"-\").slice(-1)[0];\n        // find the post using the id\n        const post = meta.posts.find((post: any) => post.id == id);\n\n        if (this.$route.params.slug != post?.slug) {\n            // create the correct slug\n            const slug = post?.slug + \"-\" + id;\n            // redirect to the correct page\n            this.$router.push({ name: \"BlogPost\", params: { slug: slug } });\n        }\n\n        return post;\n    }\n```\n\nThen all that was left was to ensure all links were using the new slug format. This was done by changing the way that the slug was being created. Instead of using the title of the post, the slug was created using the title and the id of the post. This meant that the slug would always be unique and would always be the same for the same post.\n\n#### Credits\n\nThe original idea for this post comes from: [https://www.youtube.com/watch?v=a6lnfyES-LA](https://www.youtube.com/watch?v=a6lnfyES-LA)"}
  ]
}