{
  "tags": [["meta", 1], ["vim", 1], ["nixos", 2], ["postgresql", 1], ["vue", 1], ["webdev", 1]],
  "pins": [],
  "posts": [
    {"id": 1, "title": "My workflow", "subtitle": "Keeping on track with workflow", "date": "28/12/2023", "tags": ["meta", "vim", "nixos"], "file": "posts/my-workflow.md", "slug": "my-workflow", "pinned": 0, "content": "In order to keep myself on track I wanted to document my workflow. So in order to do that this post will be kept up to date every 3 months or so with additional input and changes to how I work.\nCurrently, I use NixOS and have my neovim config managed through nix, a big thanks to [@nekowinson](https://github.com/nekowinston) for all their help.\n\nTo start right away with things that I wish to get better at:\n\n- vim motions\n- touch typing\n- go\n- rust\n- nix\n\nThis list were created in order to improve my basic workflow to improve the generic speed that I work at. To start I barely use vim motions despite using neovim as my main editor, and touch typing goes along well with this.\nAnd despite using NixOS I feel like I barely know anything about nix.\n\nIn order to also properly manage myself I have two main tools [bellado](https://github.com/isabelroses/bellado) and [vikunja](https://vikunja.io) having these two separate is really inconvenient but in order to use my to-do list well it needs to be accessible via the command line and through the web so whether I'm out and about or on my main work machine every will work well.\nOne way I plan to improve this issue is to allow bellado to interact with my vikunja instance."},
    {"id": 2, "title": "NixOS and PostgreSQL", "subtitle": "Migrating from PostgreSQL 14 to 15", "date": "27/11/2023", "tags": ["nixos", "postgresql"], "file": "posts/nixos-and-postgresql.md", "slug": "nixos-and-postgresql", "pinned": 0, "content": "When upgrading to version 15 from 14, there was an issue. None of my data was transferred. To fix this issue I swapped to the `posgres` user who is a superuser on the PostgreSQL databases.\n\nThen to preform the migration I ran:\n\n```sql\n-- to do this without swapping user you can use the flag -U\npg_dumpall > sqldump\n```\n\nthen when I had the sqldump file, the following command was run from the command line to get use the sqldump file to recover the previous data\n\n```bash\npsql -f sqldump\n```"},
    {"id": 3, "title": "Self-Healing URLs", "subtitle": "Creating self-healing URLs within my Vue.js website", "date": "10/12/2023", "tags": ["vue", "webdev"], "file": "posts/self-healing-urls.md", "slug": "self-healing-urls", "pinned": 0, "content": "I have been working on the creation of this [version](https://github.com/isabelroses/website/commit/8c53b9f3576d98a2ebe71976a3f921a30e6ad052) of my website for a while and when I finally thought I was done, I was introduced to the concept of self-healing URLs.\n\nSelf-healing URLs are designed in a way that if a user was to type in a URL as long as a certain part of the URL is correct, the user will be redirected to the correct page. This is useful for when a user is trying to access a page that has been moved or deleted.\n\nFor example, if a user was to type in [<domain>/blog/gaoengioa-2](https://isabelroses.com/blog/gaoengioa-2) they would be redirected to [<domain>/blog/self-healing-urls-2](https://isabelroses.com/blog/self-healing-urls-2) as the only important part of the URL is the \"2\" in this case, which refers to the second blog post by ID.\n\nTo implement this I had to make a few changes to my code. The original way that the post data was being fetched was by using the slug of the post. This meant that if the slug was incorrect, the post would not be found and the user would be redirected to a 404 page. To fix this I had to change the way that the post was being fetched to use the ID of the post instead. This meant that if the slug was incorrect, the post would still be found and the user would be redirected to the correct page.\n\n```js\n// the old code\nget post() {\n    return meta.posts.find((post: any) => post.slug == this.$route.params.slug);\n}\n\n// the new code\nget post() {\n    // get the id from the slug\n    const id = (this.$route.params.slug).toString().split(\"-\").slice(-1)[0];\n    // find the post using the id\n    const post = meta.posts.find((post: any) => post.id == id);\n\n    if (this.$route.params.slug != post?.slug) {\n        // create the correct slug\n        const slug = post?.slug + \"-\" + id;\n        // redirect to the correct page\n        this.$router.push({ name: \"BlogPost\", params: { slug: slug } });\n    }\n\n    return post;\n}\n```\n\nThen all that was left was to ensure all links were using the new slug format. This was done by changing the way that the slug was being created. Instead of using the title of the post, the slug was created using the title and the id of the post. This meant that the slug would always be unique and would always be the same for the same post.\n\n#### Inspiration\n\nThe original idea for this post comes from: [https://www.youtube.com/watch?v=a6lnfyES-LA](https://www.youtube.com/watch?v=a6lnfyES-LA)"}
  ]
}